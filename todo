import requests
from PIL import Image, ImageTk
import tkinter as tk
from tkinter import ttk, messagebox
from io import BytesIO
import csv

class ObraDeArte:
    """
    Esto es como una ficha de información para cada obra.
    Aquí se guardan todos los detalles de una obra:
    título, artista, año, etc.
    """

    def __init__(self, id_obra, titulo, artista, nacionalidad_artista, fecha_nacimiento, 
                 fecha_muerte, tipo, año_creacion, departamento, urlImagen):
        """
        Esta parte prepara el espacio para guardar los detalles de la obra.
        Si algún dato falta, le ponemos "SIN TITULO", "DESCONOCIDO", etc.
        para que no se quede vacío.
        """
        self.id_obra = id_obra
        self.titulo = titulo if titulo else "SIN TITULO"
        self.artista = artista if artista else "ARTISTA DESCONOCIDO"
        self.nacionalidad_artista = nacionalidad_artista if nacionalidad_artista else "NACIONALIDAD DESCONOCIDA"
        self.fecha_nacimiento = fecha_nacimiento if fecha_nacimiento else "?"
        self.fecha_muerte = fecha_muerte if fecha_muerte else "?"
        self.tipo = tipo if tipo else "Sin clasificación"
        self.año_creacion = año_creacion if año_creacion else "?"
        self.departamento = departamento if departamento else "SIN DEPARTAMENTO"
        self.urlImagen = urlImagen if urlImagen else None
    
    def mostrarDetalles(self):
        """
        Esta parte junta todos los detalles de la obra en un solo texto.
        Así se podra mostrar de forma ordenada.
        """
        detalles = [
            f"ID: {self.id_obra}",
            f"Título: {self.titulo}",
            f"Artista: {self.artista}",
            f"Nacionalidad: {self.nacionalidad_artista}",
            f"Vida: {self.fecha_nacimiento} - {self.fecha_muerte}",
            f"Tipo: {self.tipo}",
            f"Año de creación: {self.año_creacion}",
            f"Departamento: {self.departamento}"
        ]
        return "\n".join(detalles)

class CatalogoMuseo:
    """
    Este es el administrador que se encarga de todo:
    se conecta al museo, descarga las obras y las organiza.
    """
    
    def __init__(self):
        """Prepara el catálogo vacío para empezar a llenarlo."""
        self.obras = [] # Aquí se guardarán todas las obras
        self.departamentos = set() # Aquí se guardarán los nombres de los departamentos
        self.nacionalidades = set() # Aquí se guardarán las nacionalidades
        self.artistas = set() # Aquí se guardarán los nombres de los artistas
        self.cargando = False
        self.datos_cargados = False

    def cargarApi(self, progreso_callback=None):
        """
        Esta parte se conecta a internet para descargar las obras del museo.
        Lo hace en segundo plano para que la aplicación no se congele.
        """
        self.cargando = True

        try:
            # Pide la lista de obras al museo
            response = requests.get("https://collectionapi.metmuseum.org/public/collection/v1/objects")
            if response.status_code != 200:
                raise ConnectionError("¡No se pudo conectar al museo por internet!")
            
            # Limita las obras a 200 para que la descarga sea más rápida
            obras_ids = response.json().get('objectIDs', [])[:200]
            
# Pide los detalles de cada obra, uno por uno
            for i, obra_id in enumerate(obras_ids):
                if progreso_callback:
                    progreso_callback(i, len(obras_ids))
                
                try:
                    obra_response = requests.get(
                        f"https://collectionapi.metmuseum.org/public/collection/v1/objects/{obra_id}",
                        timeout=20
                    )
                    if obra_response.status_code == 200:
                        self._procesar_obra(obra_response.json())
                except requests.RequestException:
                    continue
            
            self.datos_cargados = True
        except Exception as e:
            print(f"¡ERROR al cargar los datos!: {e}")
        finally:
            self.cargando = False
    
    def _procesar_obra(self, obra_data):
        """
        Esta parte toma los datos que llegaron del museo y los
        acomoda en una "ficha de obra" usando nuestro molde `ObraDeArte`.
        """
        obra = ObraDeArte(
            obra_data.get('objectID'),
            obra_data.get('title'),
            obra_data.get('artistDisplayName'),
            obra_data.get('artistNationality'),
            obra_data.get('artistBeginDate'),
            obra_data.get('artistEndDate'),
            obra_data.get('classification'),
            obra_data.get('objectDate'),
            obra_data.get('department'),
            obra_data.get('primaryImageSmall')
        )
        
        # Guarda la obra en la lista y también los nombres únicos de
        # departamentos, nacionalidades y artistas.
        self.obras.append(obra)
        if obra.departamento:
            self.departamentos.add(obra.departamento)
        if obra.nacionalidad_artista and obra.nacionalidad_artista != "NACIONALIDAD DESCONOCIDA":
            self.nacionalidades.add(obra.nacionalidad_artista)
        if obra.artista and obra.artista != "ARTISTA DESCONOCIDO":
            self.artistas.add(obra.artista)
    
    # Herramientas de búsqueda para encontrar obras
    def buscarPorDepartamento(self, departamento):
        """Busca y devuelve obras de un departamento específico."""
        return [obra for obra in self.obras if obra.departamento == departamento]
    
    def buscarPorNacionalidad(self, nacionalidad_artista):
        """Busca y devuelve obras de artistas de una nacionalidad específica."""
        return [obra for obra in self.obras if obra.nacionalidad_artista == nacionalidad_artista]
    
    def buscarPorArtista(self, nombre_artista):
        """Busca y devuelve obras de un artista específico (o parte del nombre)."""
        nombre_lower = nombre_artista.lower()
        return [obra for obra in self.obras if nombre_lower in obra.artista.lower()]
    
    def obtenerObraPorId(self, id_obra):
        """Busca y devuelve una obra por su número de identificación único."""
        for obra in self.obras:
            if obra.id_obra == id_obra:
                return obra
        return None

class InterfazCatalogo:
    """
    Esta parte es la que crea los botones, las listas y las ventanas
    para que puedas interactuar con el programa.
    """
    
    def __init__(self, root):
        """
        Prepara la ventana principal del programa.
        """
        self.root = root
        self.catalogo = CatalogoMuseo()
        self.setupUi()
        self.cargaDatos()
    
    def setupUi(self):
        """Configura el título de la ventana y los estilos de los botones."""
        self.root.title("OBRAS DEL MUSEO / SISTEMA DE INGENIERIA")
        self.root.state('zoomed') # Maximiza la ventana
        
        self.main_frame = ttk.Frame(self.root, padding="10")
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Una barra para mostrar mensajes en la parte de abajo
        self.status_var = tk.StringVar()
        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.mostrarPantallaInicio()
    
    def mostrarPantallaInicio(self):
        """Muestra el menú principal con los botones de búsqueda."""
        self.limpiarPantalla()
        
        # Títulos y botones
        ttk.Label(self.main_frame, text="SISTEMA DE INGENIERIA", font=("Arial", 20, "bold")).pack(pady=20)
        ttk.Label(self.main_frame, text="CATALOGO DE OBRAS REALIZADAS", font=("Arial", 15, "bold")).pack(pady=20)
        ttk.Label(self.main_frame, text="INDIQUE UNA OPCION", font=("Arial", 12, "bold")).pack(pady=10)
        
        btn_frame = ttk.Frame(self.main_frame)
        btn_frame.pack(pady=20)
        
        ttk.Button(btn_frame, text="DEPARTAMENTO", command=self.mostrarDepartamentos, width=25).pack(pady=10, fill=tk.X)
        ttk.Button(btn_frame, text="NACIONALIDAD", command=self.mostrarNacionalidades, width=25).pack(pady=10, fill=tk.X)
        ttk.Button(btn_frame, text="ARTISTA", command=self.buscarPorArtista, width=25).pack(pady=10, fill=tk.X)
        ttk.Button(btn_frame, text="SALIR", command=self.root.quit, width=25).pack(pady=10, fill=tk.X)
        
        self.actualizarEstado("LOS DATOS HAN SIDO CARGADOS CON EXITO..!")
    
    def limpiarPantalla(self):
        """Borra todo lo que hay en la ventana principal para mostrar una nueva pantalla."""
        for widget in self.main_frame.winfo_children():
            widget.destroy()
    
    def actualizarEstado(self, mensaje):
        """Pone un mensaje nuevo en la barra de estado de la parte de abajo."""
        self.status_var.set(mensaje)
        self.root.update_idletasks()
    
    def cargaDatos(self):
        """Muestra un mensaje de carga y empieza a descargar los datos del museo."""
        self.actualizarEstado("CARGANDO DATOS...")
        
        ttk.Label(self.main_frame, text="CARGANDO DATOS...", font=("Arial", 17, "bold")).pack()
        ttk.Label(self.main_frame, text="POR FAVOR ESPERE...!", font=("Arial", 17, "bold")).pack()
        
        def cargarCompletado():
            self.mostrarPantallaInicio()
        
        # Le dice al "Administrador" que cargue los datos en segundo plano
        threading.Thread(target=self.catalogo.cargarApi, daemon=True).start()
        
# Revisa cada 100 milisegundos si la carga de datos ya terminó
        self.root.after(100, self.verificarCarga, cargarCompletado)
    
    def verificarCarga(self, callback):
        """Revisa si la descarga terminó para seguir al siguiente paso."""
        if self.catalogo.cargando:
            self.root.after(100, self.verificarCarga, callback)
        else:
            if self.catalogo.datos_cargados:
                callback()
            else:
                messagebox.showerror("AVISO", "NO SE PUDIERON CARGAR LOS DATOS. INTENTE MAS TARDE.")
                self.root.quit()
                
            ttk.Label(self.main_frame, text="LA CARGA DE DATOS HA SIDO COMPLETADO CON EXITO..!", font=("Arial", 17, "bold")).pack()
    
    def mostrarDepartamentos(self):
        """Muestra una lista con todos los departamentos del museo."""
        self.limpiarPantalla()
        
        ttk.Label(self.main_frame, text="SELECCIONE UN DEPARTAMENTO:", font=("Arial", 12)).pack(pady=10)
        
        list_frame = ttk.Frame(self.main_frame)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        scrollbar = ttk.Scrollbar(list_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.departamentos_list = tk.Listbox(list_frame, yscrollcommand=scrollbar.set, font=("Arial", 11), height=15)
        self.departamentos_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.departamentos_list.yview)
        
        for depto in sorted(self.catalogo.departamentos):
            self.departamentos_list.insert(tk.END, depto)
        
        btn_frame = ttk.Frame(self.main_frame)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="SELECCIONAR", command=self.seleccionarDepartamento).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ATRAS", command=self.mostrarPantallaInicio).pack(side=tk.LEFT, padx=5)
        
        self.actualizarEstado(f"{len(self.catalogo.departamentos)} DEPARTAMENTOS DISPONIBLES")
    
    def seleccionarDepartamento(self):
        """Busca las obras del departamento que seleccionaste en la lista."""
        seleccion = self.departamentos_list.curselection()
        if not seleccion:
            messagebox.showwarning("AVISO", "INDIQUE UN DEPARTAMENTO..!")
            return
        
        departamento = self.departamentos_list.get(seleccion[0])
        obras = self.catalogo.buscarPorDepartamento(departamento)
        
        if not obras:
            messagebox.showinfo("AVISO..!", f"NO HAY BUSQUEDAS PARA EL DEPARTAMENTO {departamento}")
            return
        
        self.mostrar_resultados(obras, f"OBRAS DEL DEPARTAMENTO: {departamento}")
    
    def mostrarNacionalidades(self):
        """Muestra una lista con todas las nacionalidades de los artistas."""
        self.limpiarPantalla()
        
        ttk.Label(self.main_frame, text="INDIQUE UNA NACIONALIDAD:", font=("Arial", 12)).pack(pady=10)
        
        list_frame = ttk.Frame(self.main_frame)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        scrollbar = ttk.Scrollbar(list_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.nacionalidades_list = tk.Listbox(list_frame, yscrollcommand=scrollbar.set, font=("Arial", 11), height=15)
        self.nacionalidades_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.nacionalidades_list.yview)
        
        for nacionalidad_artista in sorted(self.catalogo.nacionalidades):
            self.nacionalidades_list.insert(tk.END, nacionalidad_artista)
        
        btn_frame = ttk.Frame(self.main_frame)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="SELECCIONE", command=self.seleccionarNacionalidad).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ATRAS", command=self.mostrarPantallaInicio).pack(side=tk.LEFT, padx=5)
        
        self.actualizarEstado(f"{len(self.catalogo.nacionalidades)} NACIONALIDADES DISPONIBLES")
    
    def seleccionarNacionalidad(self):
        """Busca las obras de la nacionalidad que seleccionaste."""
        seleccion = self.nacionalidades_list.curselection()
        if not seleccion:
            messagebox.showwarning("AVISO", "DEBE INGRESAR LA NACIONALIDAD..!")
            return
        
        nacionalidad_artista = self.nacionalidades_list.get(seleccion[0])
        obras = self.catalogo.buscarPorNacionalidad(nacionalidad_artista)
        
        if not obras:
            messagebox.showinfo("AVISO", f"NO HAY OBRAS DEL ARTISTA {nacionalidad_artista}s")
            return
        
        self.mostrar_resultados(obras, f"OBRAS DEL ARTISTA {nacionalidad_artista}s")

    def buscarPorArtista(self):
        """Muestra la caja de texto para que escribas el nombre de un artista."""
        self.limpiarPantalla()
        
        ttk.Label(self.main_frame, text="INGRESE EL NOMBRE DEL ARTISTA..!:", font=("Arial", 12)).pack(pady=10)
        
        self.artista_entry = ttk.Entry(self.main_frame, font=("Arial", 12), width=40)
        self.artista_entry.pack(pady=10)
        self.artista_entry.focus()
        
        btn_frame = ttk.Frame(self.main_frame)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="BUSCAR", command=self.realizar_busqueda_artista).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ATRAS", command=self.mostrarPantallaInicio).pack(side=tk.LEFT, padx=5)
        
        self.actualizarEstado("INGRESE PARTE DEL NOMBRE DEL ARTISTA..!")

    def realizar_busqueda_artista(self):
        """Busca las obras con el nombre de artista que escribiste."""
        nombre = self.artista_entry.get().strip()
        if not nombre:
            messagebox.showwarning("AVISO", "INGRESE UN NOMBRE DEL ARTISTA..!")
            return
        
        obras = self.catalogo.buscarPorArtista(nombre)
        
        if not obras:
            messagebox.showinfo("AVISO", f"NO HAY OBRAS PARA ESTE ARTISTA '{nombre}'")
            return
        
        self.mostrar_resultados(obras, f"OBRAS DEL ARTISTA: {nombre}")
    
    def mostrar_resultados(self, obras, titulo):
        """Muestra la lista de obras que encontró la búsqueda."""
        self.limpiarPantalla()
        
        ttk.Label(self.main_frame, text=titulo, font=("Arial", 12, "bold")).pack(pady=10)
        ttk.Label(self.main_frame, text=f"{len(obras)} OBRAS ENCONTRADAS", font=("Arial", 10)).pack()
        
        list_frame = ttk.Frame(self.main_frame)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        scrollbar = ttk.Scrollbar(list_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Tabla para mostrar los resultados de forma ordenada
        self.resultados_list = ttk.Treeview(
            list_frame,
            columns=('id', 'titulo', 'artista'),
            show='headings',
            yscrollcommand=scrollbar.set,
            selectmode='browse',
            height=15
        )
        scrollbar.config(command=self.resultados_list.yview)
        
        self.resultados_list.heading('id', text='ID DEL ARTISTA')
        self.resultados_list.column('id', width=50, anchor=tk.CENTER)
        
        self.resultados_list.heading('titulo', text='TITULO DE LA OBRA')
        self.resultados_list.column('titulo', width=50, anchor=tk.W)
        
        self.resultados_list.heading('artista', text='NOMBRE DEL ARTISTA')
        self.resultados_list.column('artista', width=50, anchor=tk.W)
        
        self.resultados_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        for obra in obras:
            self.resultados_list.insert('', tk.END, values=(obra.id_obra, obra.titulo, obra.artista))
        
        btn_frame = ttk.Frame(self.main_frame)
        btn_frame.pack(pady=10)
        
        ttk.Button(btn_frame, text="VER DETALLES", command=self.verDetallesObra).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="VOLVER", command=self.mostrarPantallaInicio).pack(side=tk.LEFT, padx=5)
        
        self.actualizarEstado(f"MOSTRANDO {len(obras)} OBRAS - SELECCIONE UNA PARA VER LOS DETALLES")
    
    def verDetallesObra(self):
        """Toma la obra seleccionada de la lista y muestra todos sus detalles."""
        seleccion = self.resultados_list.selection()
        if not seleccion:
            messagebox.showwarning("AVISO", "DEBE SELECCIONAR UNA OBRA..!")
            return
        
        item = self.resultados_list.item(seleccion[0])
        id_obra = item['values'][0]
        obra = self.catalogo.obtenerObraPorId(id_obra)
        
        if not obra:
            messagebox.showerror("AVISO", "NO SE PUDO OBTENER DETALLES DE LA OBRA..!")
            return
        
        self.mostrarDetallesObra(obra)
    
    def mostrarDetallesObra(self, obra):
        """
        Muestra la información completa de una obra y un botón para
        ver la imagen.
        """
        self.limpiarPantalla()
        
        detalles_frame = ttk.Frame(self.main_frame)
        detalles_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        ttk.Label(detalles_frame, text="RESULTADOS DE ESTA OBRA", font=("Arial", 14, "bold")).pack(pady=10)
        
        detalles_text = tk.Text(detalles_frame, wrap=tk.WORD, font=("Arial", 11), height=10, padx=10, pady=10)
        detalles_text.insert(tk.END, obra.mostrarDetalles())
        detalles_text.config(state=tk.DISABLED) # No deja que el texto sea editado
        detalles_text.pack(fill=tk.X, pady=10)
        
        btn_frame = ttk.Frame(detalles_frame)
        btn_frame.pack(pady=20)
        
        if obra.urlImagen:
            ttk.Button(btn_frame, text="VER IMAGEN", command=lambda: self.mostrarImagenObra(obra), width=15).pack(side=tk.LEFT, padx=10)
        
        ttk.Button(btn_frame, text="VOLVER A RESULTADOS", command=self.mostrarPantallaInicio, width=20).pack(side=tk.LEFT, padx=10)
        ttk.Button(btn_frame, text="INICIO", command=self.mostrarPantallaInicio, width=20).pack(side=tk.LEFT, padx=10)
        
        self.actualizarEstado(f"MOSTRANDO LOS DETALLES DE LA OBRA ID: {obra.id_obra}")
    
    def mostrarImagenObra(self, obra):
        """Abre una ventana nueva para mostrar la imagen de la obra."""
        try:
            imagen_window = tk.Toplevel(self.root)
            imagen_window.title(f"IMAGEN: {obra.titulo}")
            
            loading_label = ttk.Label(imagen_window, text="CARGANDO IMAGEN...", font=("Arial", 12))
            loading_label.pack(pady=50)
            imagen_window.update()
            
            def cargar_imagen():
                try:
                    response = requests.get(obra.urlImagen, timeout=10)
                    img_data = response.content
                    img = Image.open(BytesIO(img_data))
                    
                    # Ajusta el tamaño de la imagen para que no sea muy grande
                    ancho, alto = img.size
                    max_ancho, max_alto = 800, 600
                    if ancho > max_ancho or alto > max_alto:
                        ratio = min(max_ancho/ancho, max_alto/alto)
                        nuevo_ancho = int(ancho * ratio)
                        nuevo_alto = int(alto * ratio)
                        img = img.resize((nuevo_ancho, nuevo_alto), Image.LANCZOS)
                    
                    img_tk = ImageTk.PhotoImage(img)
                    
                    # Muestra la imagen en la ventana
                    loading_label.destroy()
                    label_imagen = ttk.Label(imagen_window, image=img_tk)
                    label_imagen.image = img_tk
                    label_imagen.pack()
                
                except Exception as e:
                    loading_label.destroy()
                    messagebox.showerror("AVISO", f"NO SE PUEDO CARGAR LA IMAGEN: {str(e)}", parent=imagen_window)
                    imagen_window.destroy()
            
            # Descarga la imagen en segundo plano
            threading.Thread(target=cargar_imagen, daemon=True).start()
            
        except Exception as e:
            messagebox.showerror("AVISO..!", f"LA IMAGEN NO PUDO SER MOSTRADA..!: {str(e)}")

def main():
    """ESTA ES LA PARTE QUE ARRANCA EL PROGRAMA CUANDO SE ABRE"""
    try:
        root = tk.Tk()
        app = InterfazCatalogo(root)
        root.mainloop() # MANTIENE LA VENTANA ABIERTA Y ESPERANDO A QUE SE USE
    except Exception as e:
        messagebox.showerror("AVISO", f"ERROR AL CARGAR LA APLICACION..!: {str(e)}")

if __name__ == "__main__":
    main()
